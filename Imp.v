(* Chapter 12 Simple imperative programs *)

Require Export SfLib.


(* Arithmetic and boolean expressions *)

(* syntax *)
Module AExp.
  Inductive aexp : Type :=
    | ANum : nat -> aexp
    | APlus : aexp -> aexp -> aexp
    | AMinus : aexp -> aexp -> aexp
    | AMult : aexp -> aexp -> aexp.

  Inductive bexp : Type :=
    | BTrue : bexp
    | BFalse : bexp
    | BEq : aexp -> aexp -> bexp
    | BLe : aexp -> aexp -> bexp
    | BNot : bexp -> bexp
    | BAnd : bexp -> bexp -> bexp.

  Fixpoint aeval (a:aexp) : nat :=
    match a with
      | ANum n       => n
      | APlus a1 a2  => (aeval a1) + (aeval a2)
      | AMinus a1 a2 => (aeval a1) - (aeval a2)
      | AMult a1 a2  => (aeval a1) * (aeval a2)
    end.

  Example test_aeval1: aeval (APlus (ANum 2) (ANum 2)) = 4.
  Proof. reflexivity. Qed.

  Fixpoint beval (b:bexp) : bool :=
    match b with
      | BTrue      => true
      | BFalse     => false
      | BEq a1 a2  => beq_nat (aeval a1) (aeval a2)
      | BLe a1 a2  => ble_nat (aeval a1) (aeval a2)
      | BNot b1    => negb (beval b1)
      | BAnd b1 b2 => andb (beval b1) (beval b2)
    end.

  (* optimisation *)
  Fixpoint optimize_0plus (a:aexp) : aexp :=
    match a with
      | ANum n            => ANum n
      | APlus (ANum 0) e2 => optimize_0plus e2
      | APlus e1 e2       => APlus (optimize_0plus e1) (optimize_0plus e2)
      | AMinus e1 e2      => AMinus (optimize_0plus e1) (optimize_0plus e2)
      | AMult e1 e2       => AMult (optimize_0plus e1) (optimize_0plus e2)
    end.

  Example test_optimize_0plus:
    optimize_0plus (APlus (ANum 2)
                          (APlus (ANum 0)
                                 (APlus (ANum 0) (ANum 1)))) = APlus (ANum 2) (ANum 1).
  Proof. reflexivity. Qed.

  Theorem optimize_0plus_sound: forall a,
    aeval (optimize_0plus a) = aeval a.
  Proof.
    intros. induction a.
    Case "ANum". reflexivity.
    Case "APlus". destruct a1.
      SCase "ANum". destruct n.
        SSCase "0". simpl. apply IHa2.
        SSCase "S". simpl. rewrite IHa2. reflexivity.
      SCase "APlus". simpl in *. rewrite IHa1. rewrite IHa2. reflexivity.
      SCase "AMinus". simpl in *. rewrite IHa1. rewrite IHa2. reflexivity.
      SCase "AMult". simpl in *. rewrite IHa1. rewrite IHa2. reflexivity.
    Case "AMinus". simpl in *. rewrite IHa1. rewrite IHa2. reflexivity.
    Case "AMult". simpl in *. rewrite IHa1. rewrite IHa2. reflexivity.
  Qed.

  Theorem optimize_0plus_sound''': forall a,
    aeval (optimize_0plus a) = aeval a.
  Proof.
    intros.
    induction a.

    reflexivity.

    destruct a1.
    try (destruct n; simpl; rewrite IHa2; reflexivity).

    try (simpl in *; rewrite IHa1; rewrite IHa2; reflexivity).
    try (simpl in * ; rewrite IHa1 ; rewrite IHa2 ; reflexivity).
    try (simpl in * ; rewrite IHa1 ; rewrite IHa2 ; reflexivity).
    try (simpl in * ; rewrite IHa1 ; rewrite IHa2 ; reflexivity).
    try (simpl in * ; rewrite IHa1 ; rewrite IHa2 ; reflexivity).
Qed.


(* Coq automation *)

(* [repeat] tactical *)
Theorem ev100 : ev 100.
Proof.
  repeat (apply ev_SS). apply ev_0.
Qed.

Theorem ev100' : ev 100.
Proof.
  repeat (apply ev_0). (* does nothing *)
  repeat apply ev_SS. apply ev_0.
Qed.

(* need to watch out for tactics that always succeed in combination with repeat.
   coq's term language terminates, but the tactic language might not...
*)


(* [try] tactical *)
Theorem silly1 : forall ae, aeval ae = aeval ae.
Proof. try reflexivity. Qed.

Theorem silly2 : forall (P:Prop), P -> P.
Proof.
  intros.
  try reflexivity. (* plain [reflexivity] would fail here *)
  apply H.
Qed.

(* using [try] in a manual situation like above is silly, but [try] is handy
   when doing automated proofs in combination with [;] tactical
*)



(* [;] tactical (simple form) *)

(* T ; T'
   Perform tactic T then perform T' on each subgoal generated by T *)
Lemma foo : forall n, ble_nat 0 n = true.
Proof.
  intros. destruct n. simpl. reflexivity. simpl. reflexivity.
Qed.

Lemma foo' : forall n, ble_nat 0 n = true.
Proof.
  intros.
  destruct n;    (* destruct current goal *)
    simpl;       (* simpl each resulting subgoal *)
    reflexivity. (* refl on each of those subgoals *)
Qed.

(* Use try and ; together *)
Theorem optimize_0plus_sound' : forall a,
  aeval (optimize_0plus a) = aeval a.
Proof.
  intros.
  induction a;
    try (simpl in *; rewrite IHa1; rewrite IHa2; reflexivity).
  Case "ANum". reflexivity.
  Case "APlus".
    destruct a1;
      try (simpl in *; rewrite IHa1; rewrite IHa2; reflexivity).
    SCase "ANum".
      destruct n; simpl; rewrite IHa2; reflexivity.
Qed.

Theorem optimize_0plus_sound'' : forall a,
  aeval (optimize_0plus a) = aeval a.
Proof.
  intros.
  induction a;
    try reflexivity;
    try (simpl in *; rewrite IHa1; rewrite IHa2; reflexivity).
  (* why has coq changed the order of how things are treated?

     it's the [ T ; try T' ] idiom
     T' is attempted on all subgoals. if it succeeds, that subgoal is proven and
     so only the unsolved subgoals remain
  *)

  Case "APlus".
    destruct a1; try (simpl in *; rewrite IHa1; rewrite IHa2; reflexivity).
    SCase "ANum".
      destruct n; simpl; rewrite IHa2; reflexivity.
Qed.


(* [;] tactical (general form)


   T ; T' is shorthand for T ; [T' | T' | T' ... | T']

   T ; [T1 | T2 | T3 | ... | Tn] first performs T, then performs Ti on the ith
   subgoal generated by T
*)



(* Definining new tactic notations *)
Tactic Notation "simpl_and_try" tactic(c) := simpl ; try c.

(* Bulletproofing case analyses *)
Tactic Notation "aexp_cases" tactic(first) ident(c) :=
  first;
  [ Case_aux c "ANum"
  | Case_aux c "APlus"
  | Case_aux c "AMinus"
  | Case_aux c "AMult"
  ].


Theorem optimize_0plus_sound'''': forall a,
  aeval (optimize_0plus a) = aeval a.
Proof.
  intros.
  aexp_cases (induction a) Case;
    try reflexivity;
    try (simpl in *; rewrite IHa1; rewrite IHa2; reflexivity).
    Case "APlus".
      aexp_cases (destruct a1) SCase;
        try (simpl in *; rewrite IHa1; rewrite IHa2; reflexivity).
        SCase "ANum".
          destruct n; simpl; rewrite IHa2; reflexivity.
Qed.


(* Exercise: *** *)
Fixpoint optimize_0plus_b (b:bexp) : bexp :=
  match b with
    | BTrue  => BTrue
    | BFalse => BFalse
    | BEq a1 a2 => BEq (optimize_0plus a1) (optimize_0plus a2)
    | BLe a1 a2 => BLe (optimize_0plus a1) (optimize_0plus a2)
    | BNot e => BNot (optimize_0plus_b e)
    | BAnd e1 e2 => BAnd (optimize_0plus_b e1) (optimize_0plus_b e2)
  end.

Tactic Notation "bexp_cases" tactic(first) ident(c) :=
  first;
  [ Case_aux c "BTrue"
  | Case_aux c "BFalse"
  | Case_aux c "BEq"
  | Case_aux c "BLe"
  | Case_aux c "BNot"
  | Case_aux c "BAnd"
  ].

Theorem optimize_0plus_b_sound: forall b,
  beval (optimize_0plus_b b) = beval b.
Proof.
  intros.
  bexp_cases (induction b) Case;
    try reflexivity;
    try (simpl; rewrite IHb; reflexivity);
    try (simpl; rewrite IHb1, IHb2; reflexivity).
    Case "BEq".
      simpl. repeat rewrite optimize_0plus_sound''''. reflexivity.
    Case "BLe".
      simpl. repeat rewrite optimize_0plus_sound''''. reflexivity.
Qed. (* not very pretty, but meh *)


(* Exercise: **** *)
(* Design exercise: come up with a more sophisticated optimizer and
   prove it correct *)



(* the [omega] tactic *)
Example silly_presburger_ex: forall m n o p,
  m + n <= n + o /\ o + 3 = p + 3 ->
  m <= p.
Proof.
  intros. omega.
Qed.


(* a few more handy tactics *)


(* clear H: delete hypothesis H from the context *)
(* subst x: find assumption x = e or e = x in the context,
            replace x with e everywhere, clear assumption *)
(* subst: substitute all assumptions of the form x = e *)
(* rename H into J: rename hypothesis H to J in the context *)
(* assumption: look for a hypothesis in the context that
               matches the goal and apply it *)
(* contradiction: find H in the context that is logically
                  equivalent to False *)
(* constructor: try to find a constructor from an inductive
                definition that can solve the goal *)



(* Evaluation as a relation *)
  Reserved Notation "e '||' n" (at level 50, left associativity).

  Inductive aevalR : aexp -> nat -> Prop :=
    | E_ANum : forall (n:nat), (ANum n) || n
    | E_APlus : forall (e1 e2 : aexp) (n1 n2 : nat),
                  e1 || n1 ->
                  e2 || n2 ->
                  (APlus e1 e2) || (n1 + n2)
    | E_AMinus : forall (e1 e2 : aexp) (n1 n2 : nat),
                   e1 || n1 ->
                   e2 || n2 ->
                   (AMinus e1 e2) || (n1 - n2)
    | E_AMult : forall (e1 e2 : aexp) (n1 n2 : nat),
                  e1 || n1 ->
                  e2 || n2 ->
                  (AMult e1 e2) || (n1 * n2)
  where "e '||' n" := (aevalR e n) : type_scope.

  Tactic Notation "aevalR_cases" tactic(first) ident(c) :=
    first;
    [ Case_aux c "E_ANum"
    | Case_aux c "E_APlus"
    | Case_aux c "E_AMinus"
    | Case_aux c "E_AMult"
    ].

(* equivalence of the definitions *)
Theorem aeval_iff_aevalR : forall a n,
  (a || n) <-> aeval a = n.
Proof.
  split.
  Case "->".
    intro H. aevalR_cases (induction H) SCase; simpl.
    SCase "E_ANum". reflexivity.
    SCase "E_APlus". rewrite IHaevalR1, IHaevalR2. reflexivity.
    SCase "E_AMinus". rewrite IHaevalR1, IHaevalR2. reflexivity.
    SCase "E_AMult". rewrite IHaevalR1, IHaevalR2. reflexivity.
  Case "<-".
    generalize dependent n. aexp_cases (induction a) SCase; simpl.
    SCase "ANum".
      intros. subst. apply E_ANum.
    SCase "APlus". intros. subst. apply E_APlus. apply IHa1. reflexivity. apply IHa2. reflexivity.
    SCase "AMinus". intros. subst. apply E_AMinus. apply IHa1. reflexivity. apply IHa2. reflexivity.
    SCase "AMult". intros. subst. apply E_AMult. apply IHa1. reflexivity. apply IHa2. reflexivity.
Qed.

(* this time using more tacticals *)
Theorem aeval_iff_aevalR' : forall a n,
  (a || n) <-> aeval a = n.
Proof.
  split.
  Case "->".
    intros H.
    induction H; subst; reflexivity.
  Case "<-".
    generalize dependent n.
    induction a;
      simpl; intros; subst; constructor;
      try apply IHa1; try apply IHa2; reflexivity.
Qed.


(* Exercise: *** *)
Reserved Notation " e '|||' b " (at level 50, left associativity).

Inductive bevalR : bexp -> bool -> Prop :=
  | E_BTrue : BTrue ||| true
  | E_BFalse : BFalse ||| false
  | E_BEq : forall (a1 a2 : aexp) (n1 n2 : nat),
              a1 || n1 ->
              a2 || n2 ->
              BEq a1 a2 ||| beq_nat n1 n2
  | E_BLe : forall (a1 a2 : aexp) (n1 n2 : nat),
              a1 || n1 ->
              a2 || n2 ->
              BLe a1 a2 ||| ble_nat n1 n2
  | E_BNot : forall (e:bexp) (b:bool),
               e ||| b  ->
               BNot e ||| negb b
  | E_BAnd : forall (e1 e2 : bexp) (b1 b2:bool),
               e1 ||| b1 ->
               e2 ||| b2 ->
               BAnd e1 e2 ||| andb b1 b2
  where "e '|||' b" := (bevalR e b) : type_scope.

Tactic Notation "bevalR_cases" tactic(first) ident(c) :=
  first;
  [ Case_aux c "E_BTrue"
  | Case_aux c "E_BFalse"
  | Case_aux c "E_BEq"
  | Case_aux c "E_BLe"
  | Case_aux c "E_BNot"
  | Case_aux c "E_BAnd"
  ].

Theorem beval_iff_bevalR: forall e b,
  (e ||| b) <-> beval e = b.
Proof.
  split.
  Case "->".
    intros.
    induction H; try simpl; try subst; try reflexivity; try assumption;
    (* repeat section for: BEq and BLe *)
    repeat (replace (aeval a1) with n1; replace (aeval a2) with n2; try reflexivity; try symmetry; apply aeval_iff_aevalR; assumption).

  Case "<-".
    (* was stuck on E_BNot case.
       induction is on e, but [b] depends on [beval e]
       had to [generalize dependent b] in order for it to work *)
    generalize dependent b.
    bevalR_cases (induction e) SCase; intros;
      rewrite <- H; constructor;
      try apply aeval_iff_aevalR; (* for E_BEq and E_BLe *)
      try apply IHe;              (* for E_BNot *)
      try apply IHe1;             (* for E_BAnd *)
      try apply IHe2;             (* for E_BAnd *)
      reflexivity.
Qed.

End AExp.

(* Computational vs. relational definitions *)
Module aevalR_division.
  Inductive aexp : Type :=
    | ANum   : nat -> aexp
    | APlus  : aexp -> aexp -> aexp
    | AMinus : aexp -> aexp -> aexp
    | AMult  : aexp -> aexp -> aexp
    | ADiv   : aexp -> aexp -> aexp.

  (* functional definition of aeval: how would it handle division by 0? *)

  (* Not a problem in the relational definition *)
  Inductive aevalR : aexp -> nat -> Prop :=
    | E_ANum   : forall n : nat,
                   (ANum n) || n
    | E_APlus  : forall (a1 a2 : aexp) (n1 n2 : nat),
                   a1 || n1 ->
                   a2 || n2 ->
                   (APlus a1 a2) || (n1 + n2)
    | E_AMinus : forall (a1 a2 : aexp) (n1 n2 : nat),
                   a1 || n1 ->
                   a2 || n2 ->
                   (AMinus a1 a2) || (n1 - n2)
    | E_AMult  : forall (a1 a2 : aexp) (n1 n2 : nat),
                   a1 || n1 ->
                   a2 || n2 ->
                   (AMult a1 a2) || (n1 * n2)
    | E_ADiv   : forall (a1 a2 : aexp) (n1 n2 n3 : nat),
                   a1 || n1 ->
                   a2 || n2 ->
                   (mult n2 n3 = n1) ->
                   (ADiv a1 a2) || n3
  where "a '||' n" := (aevalR a n) : type_scope.
End aevalR_division.


(* Adding nondeterminism *)
Module aevalR_extended.
  Inductive aexp : Type :=
    | AAny : aexp (* what number comes out here? *)
    | ANum : nat -> aexp
    | APlus : aexp -> aexp -> aexp
    | AMinus : aexp -> aexp -> aexp
    | AMult : aexp -> aexp -> aexp.
  (* again, how would the aeval function handle AAny? *)

  (* not a problem for the relation *)
  Inductive aevalR : aexp -> nat -> Prop :=
    | E_Any    : forall n : nat,
                   AAny || n
    | E_ANum   : forall n : nat,
                   (ANum n) || n
    | E_APlus  : forall (a1 a2 : aexp) (n1 n2 : nat),
                   a1 || n1 ->
                   a2 || n2 ->
                   (APlus a1 a2) || (n1 + n2)
    | E_AMinus : forall (a1 a2 : aexp) (n1 n2 : nat),
                   a1 || n1 ->
                   a2 || n2 ->
                   (AMinus a1 a2) || (n1 - n2)
    | E_AMult  : forall (a1 a2 : aexp) (n1 n2 : nat),
                   a1 || n1 ->
                   a2 || n2 ->
                   (AMult a1 a2) || (n1 * n2)
  where "a '||' n" := (aevalR a n) : type_scope.
End aevalR_extended.


(* Expressions with variables *)
Module Id.
  Inductive id : Type :=
    Id : nat -> id.

  Theorem eq_id_dec: forall i1 i2 : id,
    {i1 = i2} + {i1 <> i2}.
  Proof.
    intros.
    destruct i1 as [n]. destruct i2 as [m].
    destruct (eq_nat_dec n m) as [eq | neq].
    Case "=".
      left. rewrite eq. reflexivity.
    Case "<>".
      right. intro. inversion H. apply neq, H1.
  Defined.


Lemma eq_id: forall (T:Type) x (p q : T),
  (if eq_id_dec x x then p else q) = p.
Proof.
  intros.
  destruct (eq_id_dec x x).
  Case "=". reflexivity.
  Case "<>". apply ex_falso_quodlibet. apply n. reflexivity.
Qed.


(* Exercise: * optional *)
Lemma neq_id: forall (T:Type) x y (p q : T),
  x <> y -> (if eq_id_dec x y then p else q) = q.
Proof.
  intros.
  destruct (eq_id_dec x y).
  Case "=". apply ex_falso_quodlibet, H, e.
  Case "<>". reflexivity.
Qed.

End Id.

(* State *)
Definition state := id -> nat.

Definition empty_state : state :=
  fun _ => 0.

Definition update (st:state) (x:id) (n:nat) : state :=
  fun x' => if eq_id_dec x x' then n else st x'.

(* Exercise: * *)
Theorem update_eq : forall n x st,
  (update st x n) x = n.
Proof.
  intros. unfold update.
  destruct (eq_id_dec x x); try apply ex_falso_quodlibet, n0; reflexivity.
Qed.

(* Exercise: * *)
Theorem update_neq : forall x2 x1 n st,
  x2 <> x1 ->
  (update st x2 n) x1 = (st x1).
Proof.
  intros. unfold update.
  destruct (eq_id_dec x2 x1). contradiction. reflexivity.
Qed.


(* Exercise: * *)
Theorem update_example: forall n:nat,
  (update empty_state (Id 2) n) (Id 3) = 0.
Proof.
  intros. unfold update. reflexivity.
Qed.

(* Exercise: * *)
Theorem update_shadow: forall n1 n2 x1 x2 (st:state),
  (update (update st x2 n1) x2 n2) x1 = (update st x2 n2) x1.
Proof.
  intros. unfold update. destruct (eq_id_dec x2 x1) eqn:H; reflexivity.
Qed.


(* Exercise: ** *)
Theorem update_same: forall n1 x1 x2 (st:state),
  st x1 = n1 ->
  (update st x1 n1) x2 = st x2.
Proof.
  intros. unfold update.
  destruct (eq_id_dec x1 x2) eqn:eq;
  subst; reflexivity.
Qed.


(* Exercise: *** *)
Theorem update_permute: forall n1 n2 x1 x2 x3 st,
  x2 <> x1 ->
  (update (update st x2 n1) x1 n2) x3 = (update (update st x1 n2) x2 n1) x3.
Proof.
  intros. unfold update.
  destruct (eq_id_dec x1 x3) eqn:x13. destruct (eq_id_dec x2 x3) eqn:x23.
  subst. contradiction H. reflexivity. reflexivity. reflexivity.
Qed.


(* Syntax *)
Inductive aexp : Type :=
| ANum : nat -> aexp
| AId : id -> aexp
| APlus : aexp -> aexp -> aexp
| AMinus : aexp -> aexp -> aexp
| AMult : aexp -> aexp -> aexp.

Tactic Notation "aexp_cases" tactic(first) ident(c) :=
  first;
  [ Case_aux c "ANum"
  | Case_aux c "AId"
  | Case_aux c "APlus"
  | Case_aux c "AMinus"
  | Case_aux c "AMult"
  ].

Definition X : id := Id 0.
Definition Y : id := Id 1.
Definition Z : id := Id 2.

Inductive bexp : Type :=
  | BTrue : bexp
  | BFalse : bexp
  | BEq : aexp -> aexp -> bexp
  | BLe : aexp -> aexp -> bexp
  | BNot : bexp -> bexp
  | BAnd : bexp -> bexp -> bexp.

Tactic Notation "bexp_cases" tactic(first) ident(c) :=
  first;
  [ Case_aux c "BTrue"
  | Case_aux c "BFalse"
  | Case_aux c "BEq"
  | Case_aux c "BLe"
  | Case_aux c "BNot"
  | Case_aux c "BAnd"
  ].

(* Evaluation *)
Fixpoint aeval (st:state) (a:aexp) : nat :=
  match a with
    | ANum n => n
    | AId x => st x
    | APlus a1 a2 => (aeval st a1) + (aeval st a2)
    | AMinus a1 a2 => (aeval st a1) - (aeval st a2)
    | AMult a1 a2 => (aeval st a1) * (aeval st a2)
  end.

Fixpoint beval (st : state) (b : bexp) : bool :=
  match b with
    | BTrue      => true
    | BFalse     => false
    | BEq a1 a2  => beq_nat (aeval st a1) (aeval st a2)
    | BLe a1 a2  => ble_nat (aeval st a1) (aeval st a2)
    | BNot b1    => negb (beval st b1)
    | BAnd b1 b2 => andb (beval st b1) (beval st b2)
  end.

Example aexp1:
  aeval (update empty_state X 5)
        (APlus (ANum 3) (AMult (AId X) (ANum 2)))
  = 13.
Proof. reflexivity. Qed.

Example bexp1:
  beval (update empty_state X 5)
        (BAnd BTrue (BNot (BLe (AId X) (ANum 4))))
  = true.
Proof. reflexivity. Qed.



(* Commands *)

(*
   informally, our commands have the following BNF grammar

   c ::= SKIP
       | x ::= a
       | c ;; c
       | WHILE b DO c END
       | IFB b THEN c ELSE c FI
*)

(*
   factorial in Imp:

   Z ::= X;;
   Y ::= 1;;
   WHILE not (Z = 0) DO
     Y ::= Y * Z;;
     Z ::= Z - 1
   END
*)

Inductive com : Type :=
  | CSkip : com
  | CAss : id -> aexp -> com
  | CSeq : com -> com -> com
  | CIf : bexp -> com -> com -> com
  | CWhile : bexp -> com -> com.

Tactic Notation "com_cases" tactic(first) ident(c) :=
  first;
  [ Case_aux c "SKIP"
  | Case_aux c "::="
  | Case_aux c "IFB"
  | Case_aux c "WHILE"
  ].

Notation "'SKIP'" := CSkip.
Notation "x '::=' a" :=
  (CAss x a) (at level 60).
Notation "c1 ;; c2" :=
  (CSeq c1 c2) (at level 80, right associativity).
Notation "'WHILE' b 'DO' c 'END'" :=
  (CWhile b c) (at level 80, right associativity).
Notation "'IFB' c 'THEN' a 'ELSE' b 'FI'" :=
  (CIf c a b) (at level 80, right associativity).

Definition fact_in_coq : com :=
  Z ::= AId X;;
  Y ::= ANum 1;;
  WHILE BNot (BEq (AId Z) (ANum 0)) DO
    Y ::= AMult (AId Y) (AId Z);;
    Z ::= AMinus (AId Z) (ANum 1)
  END.


(* Examples *)
Definition plus2 : com :=
  X ::= (APlus (AId X) (ANum 2)).

Definition XtimesYinZ : com :=
  Z ::= (AMult (AId X) (AId Y)).

Definition subtract_slowly_body : com :=
  Z ::= AMinus (AId Z) (ANum 1) ;;
  X ::= AMinus (AId X) (ANum 1).

(* loops *)
Definition subtract_slowly : com :=
  WHILE BNot (BEq (AId X) (ANum 0)) DO
    subtract_slowly_body
  END.

Definition subtract_3_from_5_slowly : com :=
  X ::= ANum 3 ;;
  Z ::= ANum 5 ;;
  subtract_slowly.

(* infinite loop *)
Definition loop : com :=
  WHILE BTrue DO
    SKIP
  END.



(* Evaluation *)
Fixpoint ceval_fun_no_while (st:state) (c:com) : state :=
  match c with
    | SKIP => st
    | x ::= a1 => update st x (aeval st a1)
    | c1 ;; c2 => let st' := ceval_fun_no_while st c1
                  in  ceval_fun_no_while st' c2
    | IFB c THEN a ELSE b FI => if   (beval st c)
                                then ceval_fun_no_while st a
                                else ceval_fun_no_while st b
    | WHILE b DO c END => st (* bogus *)
  end.


(* Evaluation as a relation *)
Reserved Notation "c1 '/' st '||' st'" (at level 40, st at level 39).

Inductive ceval : com -> state -> state -> Prop :=
  | E_Skip : forall st, SKIP / st || st
  | E_Ass : forall st a n x,
              aeval st a = n ->
              (x ::= a) / st || (update st x n)
  | E_Seq : forall c1 c2 st st' st'',
              c1 / st || st' ->
              c2 / st' || st'' ->
              (c1 ;; c2) / st || st''
  | E_IfTrue : forall st st' c a b,
                 beval st c = true ->
                 a / st || st' ->
                 (IFB c THEN a ELSE b FI) / st || st'
  | E_IfFalse : forall st st' c a b,
                  beval st c = false ->
                  b / st || st' ->
                  (IFB c THEN a ELSE b FI) / st || st'
  | E_WhileEnd : forall b st c,
                   beval st b = false ->
                   (WHILE b DO c END) / st || st
  | E_WhileLoop : forall st st' st'' b c,
                    beval st b = true ->
                    c / st || st' ->
                    (WHILE b DO c END) / st' || st'' ->
                    (WHILE b DO c END) / st || st''
  where "c '/' st '||' st'" := (ceval c st st').

Tactic Notation "ceval_cases" tactic(first) ident(c) :=
  first;
  [ Case_aux c "E_Skip"
  | Case_aux c "E_Ass"
  | Case_aux c "E_Seq"
  | Case_aux c "E_IfTrue"
  | Case_aux c "E_IfFalse"
  | Case_aux c "E_WhileEnd"
  | Case_aux c "E_WhileLoop"
  ].


Example ceval_example1:
  (X::=ANum 2 ;;
   IFB BLe (AId X) (ANum 1)
     THEN Y ::= ANum 3
     ELSE Z ::= ANum 4
   FI)
  / empty_state || (update (update empty_state X 2) Z 4).
Proof.
  apply E_Seq with (update empty_state X 2).
  Case "::=". apply E_Ass. reflexivity.
  Case "if".
    apply E_IfFalse. reflexivity. apply E_Ass. reflexivity.
Qed.


(* Exercise: ** *)
Example ceval_example2:
  (X ::= ANum 0;;
   Y ::= ANum 1;;
   Z ::= ANum 2)
  / empty_state || (update (update (update empty_state X 0) Y 1) Z 2).
Proof.
  try apply E_Seq with (update empty_state X 0);
  try apply E_Seq with (update (update empty_state X 0) Y 1);
  apply E_Ass;
  reflexivity.
Qed.

(* Exercise: *** advanced *)
Definition pup_to_n : com :=
  (Y ::= ANum 0;;
   WHILE BNot (BEq (ANum 0) (AId X)) DO
     Y ::= APlus (AId Y) (AId X);;
     X ::= AMinus (AId X) (ANum 1)
   END).

Theorem pup_to_2_ceval:
  pup_to_n /
  (update empty_state X 2) ||
  update (update (update (update (update (update empty_state X 2) Y 0) Y 2) X 1) Y 3) X 0.
Proof.
  apply E_Seq with (update (update empty_state X 2) Y 0).
  (* Y 0 *) apply E_Ass. reflexivity.

  (* while conditional *)
  apply E_WhileLoop with (update (update (update (update empty_state X 2) Y 0) Y 2) X 1).
  reflexivity.
  (* while body *) apply E_Seq with (update (update (update empty_state X 2) Y 0) Y 2).
  (* Y = *) apply E_Ass. reflexivity.
  (* X = *) apply E_Ass. reflexivity.

  (* while conditional *)
  apply E_WhileLoop with (update (update (update (update (update (update empty_state X 2) Y 0) Y 2) X 1) Y 3) X 0). reflexivity.
  (* while body *) apply E_Seq with (update (update (update (update (update empty_state X 2) Y 0) Y 2) X 1) Y 3).
  (* Y ::= *) apply E_Ass. reflexivity.
  (* X ::= *) apply E_Ass. reflexivity.

  apply E_WhileEnd. reflexivity.
Qed.

Theorem ceval_deterministic: forall c st st1 st2,
  c / st || st1 ->
  c / st || st2 ->
  st1 = st2.
Proof.
  intros c st st1 st2 E1 E2. generalize dependent st2. ceval_cases (induction E1) Case; intros st2 E2; inversion E2; subst.
  Case "E_Skip".
    reflexivity.
  Case "E_Ass".
    reflexivity.
  Case "E_Seq".
    assert (st' = st'0) as eq1.
    apply IHE1_1; assumption. subst. apply IHE1_2. assumption.
  Case "E_IfTrue".
    apply IHE1. assumption. rewrite H in H5. inversion H5.
  Case "E_IfFalse".
    rewrite H in H5. inversion H5. apply IHE1. assumption.
  Case "E_WhileEnd".
    reflexivity. rewrite H in H2. inversion H2.
  Case "E_WhileLoop".
    rewrite H in H4. inversion H4.
    assert (st' = st'0) as eq1. apply IHE1_1; assumption.
    subst st'0. apply IHE1_2. assumption.
Qed.



(* Reasoning about Imp programs *)
Theorem plus2_spec: forall st n st',
  st X = n ->
  plus2 / st || st' ->
  st' X = n + 2.
Proof.
  intros st n st' hx heval.
  inversion heval. subst. apply update_eq.
Qed.

(* Exercise: *** *)
(* prove a specification of XtimesYinZ *)
Theorem XtimesYinZ_spec: forall st n st',
  st X = n ->
  XtimesYinZ / st || st' ->
  st' X = n.
Proof.
  intros st n st' xn ev. generalize dependent n.
  induction ev; intros; try assumption.
  subst.
Admitted.

(* Exercise: *** *)
Theorem loop_never_stops: forall st st',
  ~ (loop / st || st').
Proof.
  intros st st' contra. unfold loop in contra.
  remember (WHILE BTrue DO SKIP END) as loopdef eqn:eqld.
  ceval_cases(induction contra) Case; inversion eqld.
  Case "E_WhileEnd". subst. inversion H.
  Case "E_WhileLoop". apply IHcontra2. subst. reflexivity.
Qed.

(* Exercise: *** *)
Fixpoint no_whiles (c:com) : bool :=
  match c with
    | SKIP => true
    | _ ::= _ => true
    | c1 ;; c2 => andb (no_whiles c1) (no_whiles c2)
    | IFB _ THEN a ELSE b FI => andb (no_whiles a) (no_whiles b)
    | WHILE _ DO _ END => false
  end.

Inductive no_whilesR: com -> Prop :=
  | n_skip : no_whilesR SKIP
  | n_asgn : forall x a, no_whilesR (x ::= a)
  | n_seq  : forall a b, no_whilesR a -> no_whilesR b -> no_whilesR (a ;; b)
  | n_if   : forall c a b, no_whilesR a -> no_whilesR b -> no_whilesR (IFB c THEN a ELSE b FI).

Theorem no_whiles_eqv: forall c,
  no_whiles c = true <-> no_whilesR c.
Proof.
  intro c. split.
  Case "->".
    induction c; intros; try constructor.
    SCase "::=".
      simpl in H.
      apply IHc1. apply andb_true_elim1 in H. assumption.
      apply IHc2. apply andb_true_elim2 in H. assumption.
    SCase "IF".
      simpl in H.
      apply IHc1. apply andb_true_elim1 in H. assumption.
      apply IHc2. apply andb_true_elim2 in H. assumption.
    SCase "WHILE".
      inversion H.

  Case "<-".
    induction c; intros; simpl; try rewrite IHc1, IHc2; try reflexivity;
    repeat (try inversion H; try assumption).
Qed.


(* Exercise: **** *)
(* state and prove a theorem that says 'if there are no while loops in an imp
   program, then it always terminates' *)



(* Additional exercises *)

(* Exercise: *** stack compiler *)
Inductive sinstr : Type :=
| SPush : nat -> sinstr
| SLoad : id -> sinstr
| SPlus : sinstr
| SMinus : sinstr
| SMult : sinstr.

Fixpoint s_execute (st:state) (stack:list nat) (prog:list sinstr) : list nat :=
  match prog with
    | nil => stack
    | ins :: inss => match ins, stack with
                       | SPush n, _              => s_execute st (n :: stack) inss
                       | SLoad i, _              => s_execute st (st i :: stack) inss
                       | SPlus, (a :: (b :: c))  => s_execute st ((a + b) :: c) inss
                       | SMinus, (a :: (b :: c)) => s_execute st ((b - a) :: c) inss
                       | SMult, (a :: (b :: c))  => s_execute st ((a * b) :: c) inss
                       | _, _                    => stack
                     end
  end.

Example s_execute1: s_execute empty_state []
  [SPush 5; SPush 3; SPush 1; SMinus] = [2;5].
Proof. reflexivity. Qed.

Example s_execute2: s_execute (update empty_state X 3) [3;4]
  [SPush 4; SLoad X; SMult; SPlus] = [15;4].
Proof. reflexivity. Qed.

Fixpoint s_compile (e:aexp) : list sinstr :=
  match e with
    | ANum n     => [SPush n]
    | AId i      => [SLoad i]
    | APlus n m  => s_compile n ++ s_compile m ++ [SPlus]
    | AMinus n m => s_compile n ++ s_compile m ++ [SMinus]
    | AMult n m  => s_compile n ++ s_compile m ++ [SMult]
  end.

Example s_compile1: s_compile
  (AMinus (AId X) (AMult (ANum 2) (AId Y))) = [SLoad X; SPush 2; SLoad Y; SMult; SMinus].
Proof. reflexivity. Qed.

(* Exercise: *** advanced *)
Theorem s_compile_correct: forall (st:state) (e:aexp),
  s_execute st [] (s_compile e) = [aeval st e].
Proof.
  intros.
  induction e; simpl; try reflexivity.
Admitted.


(* Exercise: ***** advanced *)
Module BreakImp.
  Inductive com : Type :=
    | CSkip : com
    | CBreak : com
    | CAss : id -> aexp -> com
    | CSeq : com -> com -> com
    | CIf  : bexp -> com -> com -> com
    | CWhile : bexp -> com -> com.

  Tactic Notation "com_cases" tactic(first) ident(c) :=
    first;
    [ Case_aux c "SKIP"
    | Case_aux c "BREAK"
    | Case_aux c "::="
    | Case_aux c ";"
    | Case_aux c "IFB"
    | Case_aux c "WHILE"
    ].

  Notation "'SKIP'"    := CSkip.
  Notation "'BREAK'"   := CBreak.
  Notation "x '::=' a" := (CAss x a) (at level 60).
  Notation "c1 ; c2"   := (CSeq c1 c2) (at level 80, right associativity).
  Notation "'WHILE' b 'DO' c 'END'" :=
    (CWhile b c) (at level 80, right associativity).
  Notation "'IFB' c1 'THEN' c2 'ELSE' c3 'FI'" :=
    (CIf c1 c2 c3) (at level 80, right associativity).

  (* BREAK should exit the inner most loop only, if it is called outside
     a loop, the program terminates.
  *)

  Inductive status : Type :=
    | SContinue : status
    | SBreak : status.

  Reserved Notation "c '/' st '||' s '/' st'" (at level 40, st, s at level 39).
End BreakImp.
